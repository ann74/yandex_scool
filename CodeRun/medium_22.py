# 22. Минимум на отрезке
# Рассмотрим последовательность целых чисел длины n. По ней с шагом 1 двигается «окно» длины k, то есть сначала
# в «окне» видны первые k чисел, на следующем шаге в «окне» уже будут находиться k чисел, начиная со второго,
# и так далее до конца последовательности. Требуется для каждого положения «окна» определить минимум в нём.
# Формат ввода
# В первой строке входных данных содержатся два натуральных числа n и k (n ≤ 150000, k ≤ 10000, k ≤ n) – длины
# последовательности и «окна», соответственно. На следующей строке находятся n чисел – сама последовательность.
# Формат вывода
# Выходые данные должны содержать n−k+1 строк – минимумы для каждого положения «окна».
# Примечание
# Обратите внимание, что решение с непосредственным подсчётом минимума для каждого положения окна не пройдёт по
# времени. Один из способов решить задачу – использовать контейнер C++ std::multiset или его аналог, чтобы
# хранить содержимое окна и быстро получать минимум. Подробнее об std::multiset читайте здесь:
# http://en.cppreference.com/w/cpp/container/multiset.
# Пример 1
# Ввод            Вывод
# 7 3             1
# 1 3 2 4 5 3 1   2
#                 2
#                 3
#                 1
from collections import deque

def main():
    n, k = map(int, input().split())
    nums = list(map(int, input().split()))
    deq = deque()
    for i in range(k):
        while deq and deq[-1][0] > nums[i]:
            deq.pop()
        deq.append((nums[i], i))
    print(deq[0][0])
    for j in range(k, n):
        if deq[0][1] <= j - k:
            deq.popleft()
        while deq and deq[-1][0] > nums[j]:
            deq.pop()
        deq.append((nums[j], j))
        print(deq[0][0])


if __name__ == '__main__':
    main()