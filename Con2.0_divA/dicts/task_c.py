# C. Драгоценные камни
# В одной далекой восточной стране до сих пор по пустыням ходят караваны верблюдов, с помощью которых купцы
# перевозят пряности, драгоценности и дорогие ткани. Разумеется, основная цель купцов состоит в том, чтобы
# подороже продать имеющийся у них товар. Недавно один из караванов прибыл во дворец одного могущественного шаха.
# Купцы хотят продать шаху n драгоценных камней, которые они привезли с собой. Для этого они выкладывают их перед
# шахом в ряд, после чего шах оценивает эти камни и принимает решение о том, купит он их или нет. Видов драгоценных
# камней на Востоке известно не очень много всего 26, поэтому мы будем обозначать виды камней с помощью строчных
# букв латинского алфавита. Шах обычно оценивает камни следующим образом. Он заранее определил несколько
# упорядоченных пар типов камней: (a1, b1), (a2, b2), ..., (ak, bk). Эти пары он называет красивыми, их множество
# мы обозначим как P. Теперь представим ряд камней, которые продают купцы, в виде строки S длины n из строчных
# букв латинского алфавита. Шах считает число таких пар (i, j), что 1 ≤ i < j ≤ n, а камни Si и Sj образуют
# красивую пару, то есть существует такое число 1 ≤ q ≤ k, что Si = aq и Sj = bq.
# Если число таких пар оказывается достаточно большим, то шах покупает все камни. Однако в этот раз купцы привезли
# настолько много камней, что шах не может посчитать это число. Поэтому он вызвал своего визиря и поручил ему этот
# подсчет. Напишите программу, которая находит ответ на эту задачу.
# Формат ввода
# Первая строка входного файла содержит целые числа n и k (1 ≤ n ≤ 100000, 1 ≤ k ≤ 676) число камней, которые
# привезли купцы и число пар, которые шах считает красивыми. Вторая строка входного файла содержит строку S,
# описывающую типы камней, которые привезли купцы.
# Далее следуют k строк, каждая из которых содержит две строчных буквы латинского алфавита и описывает одну из
# красивых пар камней.
# Формат вывода
# В выходной файл выведите ответ на задачу — количество пар, которое должен найти визирь.
# Пример 1
# Ввод	  Вывод
# 7 1       6
# abacaba
# aa


# Можно сделать проход вперед или назад. При проходе вперед, при считывании пар, для каждого второго камня пары,
# фиксируем в словарь множество всех возможных первых камней. Проходя вперед, подсчитываем в словаре буквы,
# и для очередной буквы, проходимся по всем возможным буквам для пары и суммируем сколько их уже есть в словаре

n, k = map(int, input().split())
rocks = input().strip()
nice_pairs = {}
for _ in range(k):
    first, second = list(input().strip())
    if second not in nice_pairs:
        nice_pairs[second] = set()
    nice_pairs[second].add(first)

rocks_dict = {}
res = 0
for rock in rocks:
    for pair in nice_pairs.get(rock, set()):
        if pair in rocks_dict:
            res += rocks_dict[pair]
    rocks_dict[rock] = rocks_dict.get(rock, 0) + 1

print(res)