# E. Амбициозная улитка
# Домашний питомец мальчика Васи — улитка Петя. Петя обитает на бесконечном в обе стороны вертикальном столбе,
# который для удобства можно представить как числовую прямую. Изначально Петя находится в точке 0. Вася кормит
# Петю ягодами. У него есть n ягод, каждая в единственном экземпляре. Вася знает, что если утром он даст Пете
# ягоду с номером i, то поев и набравшись сил, за остаток дня Петя поднимется на ai единиц вверх по столбу,
# но при этом за ночь, потяжелев, съедет на bi единиц вниз. Параметры различных ягод могут совпадать.
# Пете стало интересно, а как оно там, наверху, и Вася взялся ему в этом помочь. Ближайшие n дней он будет
# кормить Петю ягодами из своего запаса таким образом, чтобы максимальная высота, на которой побывал Петя за эти
# n дней была максимальной. К сожалению, Вася не умеет программировать, поэтому он попросил вас о помощи.
# Найдите, максимальную высоту, на которой Петя сможет побывать за эти n дней и в каком порядке Вася должен
# давать Пете ягоды, чтобы Петя смог её достичь!
# Формат ввода
# В первой строке входных данных дано число n (1≤n≤5⋅105) — количество ягод у Васи. В последующих n строках
# описываются параметры каждой ягоды. В i+1 строке дано два числа ai и bi (0≤ai,bi≤109) — то, насколько поднимется
# улитка за день после того, как съест i ягоду и насколько опуститься за ночь.
# Формат вывода
# В первой строке выходных данных выведите единственное число — максимальную высоту, которую сможет достичь
# Петя, если Вася будет его кормить оптимальным образом. В следующей строке выведите n различных целых чисел от
# 1 до n — порядок, в котором Вася должен кормить Петю (i число в строке соответствует номеру ягоды,
# которую Вася должен дать Пете в i день чтобы Петя смог достичь максимальной высоты).
# Пример 1
# Ввод	Вывод
# 3       10
# 1 5     2 3 1
# 8 2
# 4 4


n = int(input())
positive = []
negative = []
for i in range(1, n + 1):
    berry = tuple(map(int, input().split()))
    if berry[0] - berry[1] > 0:
        positive.append((*berry, i))
    else:
        negative.append((*berry, i))

max_positive = 0
if positive:
    max_positive = max(positive, key=lambda x: x[1])
    positive.remove(max_positive)
max_negative = 0
if negative:
    max_negative = max(negative)

dist = 0
for i in range(len(positive)):
    dist += positive[i][0]
    dist -= positive[i][1]
if max_positive:
    dist += max_positive[0]
if max_negative and max_positive:
    print(max(dist, dist - max_positive[1] + max_negative[0]))
elif max_positive:
    print(dist)
else:
    print(dist + max_negative[0])
for berry in positive:
    print(berry[2], end=" ")
if max_positive:
    print(max_positive[2], end=" ")
if max_negative:
    print(max_negative[2], end=" ")
for berry in negative:
    if berry != max_negative:
        print(berry[2], end=" ")
